# Тарвин Максим УИБО-14-24
# Алгоритмы сортировки и поиска
## 1.Сортировка выбором (Selection Sort)
Сортировка выбором (Selection Sort) — на каждом шаге алгоритма находят минимальный
элемент среди последних и меняют его местами с текущим элементом в массиве.
# Объяснение работы алгоритма:
• на каждом шаге выбирается минимальный элемент из неотсортированной части
массива
• найденный минимальный элемент меняется местами с первым элементом в
неотсортированной части
• процесс повторяется для оставшейся части массива
# Временная сложность алгоритма:
O(n²) в худшем, среднем и лучшем случаях, где n - количество элементов в массиве.
Пример вывода:
Исходный массив: 64 25 12 22 11
Отсортированный массив: 11 12 22 25 64
## 2. Сортировка обменом (Bubble Sort)
# Сортировка обменом (пузырьком) (Bubble Sort) — 
алгоритм проходит по списку несколько
раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном
порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется.
# Объяснение работы кода:
• функция bubbleSort принимает массив и его размер
• использует два вложенных цикла:
• внешний цикл контролирует количество проходов по массиву
• внутренний цикл выполняет сравнение соседних элементов
• при каждом проходе самый большой элемент «всплывает» в конец массива
• функция printArray используется для вывода содержимого массива
Big O: O(n²) худший/средний, O(n) лучший (если добавить проверку на отсутствие обменов); память O(1).
Пример вывода:
Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]
## 3. Сортировка вставками (Insertion Sort)
# Сортировка вставками (Insertion Sort) — 
алгоритм строит отсортированную часть списка,
постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и
перемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его
на правильное место.
# Объяснение работы алгоритма:
• алгоритм делит массив на две части: отсортированную и несортированную
• изначально первый элемент считается отсортированным
• берется следующий элемент и вставляется в правильное место в отсортированной части
• процесс повторяется до тех пор, пока все элементы не будут отсортированы
Big O: O(n²) средний/худший; O(n) лучший; память O(1).
# Пример вывода:
`Исходный массив: 12 11 13 5 6`
`Отсортированный массив: 5 6 11 12 13`
## 4. Сортировка слиянием (Merge Sort)
# Сортировка слиянием (Merge Sort) — 
алгоритм состоит в разделении массива пополам,
сортировке половин и их слиянии.
# Этот код реализует алгоритм сортировки слиянием, который работает следующим
образом:
• массив делится пополам до тех пор, пока не останутся массивы длиной 1
• отсортированные половинки сливаются обратно в один массив
• процесс повторяется рекурсивно
# Временная сложность алгоритма:
O(n log n) в худшем, среднем и лучшем случаях
# Пространственная сложность:
O(n) из-за использования дополнительных массивов
# Пример вывода:
`Исходный массив: 38 27 43 3 9 82 10`
`Отсортированный массив: 3 9 10 27 38 43 82`
## 5.Сортировка Шелла (Shell Sort)
# Сортировка Шелла (Shellsort) — 
является модификацией сортировки вставками, сортирует
между собой элементы, стоящие на местах, кратных определённому шагу.
# Основные моменты алгоритма:
• использует последовательность промежутков (gap)
• на каждом шаге сортирует элементы, находящиеся на расстоянии gap друг от друга
• постепенно уменьшает gap до 1
• в итоге получается полностью отсортированный массив
# Программа включает:
• функцию сортировки
• вспомогательную функцию вывода массива
• пример использования в main()
Big O: зависит от последовательности gap; типично от ~O(n^(3/2)) до O(n²). Память O(1).
# Пример вывода:
`Исходный массив: 12 34 54 2 3`
`Отсортированный массив: 2 3 12 34 54`
## 6. Быстрая сортировка (Quick Sort)
# Быстрая сортировка (Quick Sort) — 
один из самых известных и широко используемых
алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива
на две части относительно опорного (одна — все элементы, меньшие опорного элемента,
вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них.
# Этот код реализует классический алгоритм быстрой сортировки. Основные моменты:
• метод quickSort является рекурсивным и выполняет основную сортировку
• метод partition выбирает опорный элемент и перестраивает массив
• вспомогательный метод printArray используется для вывода массива на экран
Big O: средняя O(n log n), худшая O(n²); память O(log n) средняя (рекурсивный стек).
# Пример вывода:
Исходный массив: [10, 7, 8, 9, 1, 5]
Отсортированный массив: [1, 5, 7, 8, 9, 10]
## 7. Пирамидальная сортировка (Heap Sort)
# Пирамидальная сортировка — 
алгоритм строит кучу из исходного списка, затем постепенно
извлекает наибольший элемент из кучи и помещает его в конец списка.
# Этот код реализует алгоритм пирамидальной сортировки, который состоит из двух основных этапов:
• построение max-heap из входного массива
• последовательное извлечение максимального элемента из heap и его перемещение в
конец массива
• функция heapify поддерживает свойство heap для поддерева с корнем в индексе i.
Основная функция heap_sort сначала строит heap, а затем сортирует массив.
Big O: O(n log n) во всех случаях; память O(1) (in-place, кроме рекурсии в heapify).
# Пример вывода:
Исходный массив: 12 11 13 5 6 7
Отсортированный массив: 5 6 7 11 12 13
## 8. Последовательный (линейный) поиск
# Последовательный (линейный) поиск — 
простейший вид поиска заданного элемента на
некотором множестве. Осуществляется путём последовательного сравнения очередного
рассматриваемого значения с искомым до тех пор, пока эти значения не совпадут. Этот метод
является наименее эффективным, так как его временная сложность составляет O(n), где n —
количество элементов в списке. Однако он прост в реализации и может быть полезен для
небольших списков или в тех случаях, когда данные не отсортированы.
# Принцип работы алгоритма:
• алгоритм начинает с первого элемента массива
• сравнивает текущий элемент с искомым значением
• если значения равны, возвращается индекс элемента
• если нет — алгоритм переходит к следующему элементу
• процесс повторяется до тех пор, пока не будет найден элемент или не будет достигнут
конец массива
# Временная сложность:
O(n), где n — количество элементов в массиве
Пространственная сложность: O(1)
# Пример вывода:
Исходный массив: [3, 5, 2, 7, 9, 1, 4]
Элемент 7 найден на позиции (0-based): 3
## 9. Бинарный (двоичный) поиск
# Бинарный (двоичный, дихотомический) поиск — 
это поиск заданного элемента на
упорядоченном множестве, осуществляемый путём неоднократного деления этого множества
на две части таким образом, что искомый элемент попадает в одну из этих частей. Поиск
заканчивается при совпадении искомого элемента с элементом, который является границей
между частями множества или при отсутствии искомого элемента. Преимуществом бинарного
поиска является более низкая трудоёмкость по сравнению с последовательным поиском.
Недостаток заключается в том, что он применим только на отсортированных множествах.
# Пояснение работы кода:
• метод binarySearch принимает отсортированный массив и искомое значение.
• используются две переменные: left и right для отслеживания границ поиска.
• в цикле while происходит поиск:
• вычисляется середина массива.
• сравнивается средний элемент с искомым.
• в зависимости от результата сравнения корректируются границы поиска.
• если элемент найден, возвращается его индекс.
• если элемент не найден, возвращается -1.
Big O: O(log n) время, O(1) память.
# Пример вывода:
Исходный отсортированный массив: 1 3 5 7 9 11 13 15
Элемент 7 найден на позиции (0-based): 3
## 10. Интерполяционный поиск 
# Интерполирующий поиск — 
это алгоритм поиска для отсортированных наборов данных,
таких как массивы или списки. Он предсказывает позицию нужного элемента на основе
разницы значений. Эффективен, если элементы распределены достаточно равномерно.
# Объяснение: 
на каждой итерации цикла область поиска сужается, пока не будет найден
искомый элемент, либо пока не станет ясно, что он отсутствует в массиве. Если элемент не
найден, функция возвращает значение -1.
# Временная сложность интерполяционного поиска:
O(log log n) — когда значения распределены равномерно.
O(n) — если значения распределены неравномерно (наихудший случай).
# Пример вывода:
Исходный массив: [10, 20, 30, 40, 50, 60, 70, 80]
Элемент 50 найден на позиции (0-based): 4
## 11. Поиск по Фибоначчи
# Поиск по Фибоначчи — 
это эффективный алгоритм поиска, используемый для нахождения
целевого значения в отсортированной коллекции, такой как массив или список. По принципу
он аналогичен бинарному поиску, но использует числа Фибоначчи для определения позиций
для сравнения.
# Объяснение работы:
• сначала генерируются числа Фибоначчи до тех пор, пока не найдётся число, большее
или равное размеру массива.
• используется три последовательных числа Фибоначчи: F[m], F[m-1], F[m-2].
• на каждом шаге сравнивается элемент с ключом:
• если элемент меньше ключа — переходим к правому подмассиву.
• если элемент больше ключа — переходим к левому подмассиву.
• если равны — элемент найден.
• процесс продолжается, пока F[m] не станет равным 1.
Big O: O(log n) время, O(1) память.
# Пример вывода:
Исходный массив: [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
Элемент 85 найден на позиции (0-based): 8
