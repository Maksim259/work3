# Тарвин Максим УИБО-14-24
# Алгоритмы сортировки и поиска
## 1.Сортировка выбором (Selection Sort)
Объяснение: на каждом шаге выбирается минимальный элемент в неотсортированной части и меняется местами с первым элементом этой части; повторяют n−1 раз.
Big O: время O(n²) (лучший/средний/худший), память O(1).
Пример вывода:
Исходный массив: 64 25 12 22 11
Отсортированный массив: 11 12 22 25 64
## 2. Сортировка обменом (Bubble Sort)
Объяснение: повторно сравниваем пары соседних элементов и меняем их при необходимости; после каждого прохода самый большой элемент оказывается в конце.
Big O: O(n²) худший/средний, O(n) лучший (если добавить проверку на отсутствие обменов); память O(1).
Пример вывода:
Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]
## 3. Сортировка вставками (Insertion Sort)
Объяснение: строит отсортированную часть слева, вставляя каждый следующий элемент в нужное место.
Big O: O(n²) средний/худший; O(n) лучший; память O(1).
Пример вывода:
`Исходный массив: 12 11 13 5 6`
`Отсортированный массив: 5 6 11 12 13`
## 4. Сортировка слиянием (Merge Sort)
Объяснение: делим массив рекурсивно на половины до длины 1, затем сливаем отсортированные части.
Big O: O(n log n) во всех случаях; память O(n).
Пример вывода:
`Исходный массив: 38 27 43 3 9 82 10`
`Отсортированный массив: 3 9 10 27 38 43 82`
## 5.Сортировка Шелла (Shell Sort)
Объяснение: улучшение insertion sort — сначала сортируем элементы на расстоянии gap, затем уменьшаем gap, последняя итерация gap=1 — обычная вставка.
Big O: зависит от последовательности gap; типично от ~O(n^(3/2)) до O(n²). Память O(1).
Пример вывода:
`Исходный массив: 12 34 54 2 3`
`Отсортированный массив: 2 3 12 34 54`
## 6. Быстрая сортировка (Quick Sort)
Объяснение: выбираем pivot, разделяем элементы на <=pivot и >pivot, рекурсивно сортируем обе части. Быстро на практике, худший случай O(n²) при плохом pivot.
Big O: средняя O(n log n), худшая O(n²); память O(log n) средняя (рекурсивный стек).
Пример вывода:
Исходный массив: [10, 7, 8, 9, 1, 5]
Отсортированный массив: [1, 5, 7, 8, 9, 10]
## 7. Пирамидальная сортировка (Heap Sort)
Объяснение: строим max-heap, затем последовательно извлекаем корень (максимум) и ставим его в конец массива; повторяем, пока не отсортируем весь массив.
Big O: O(n log n) во всех случаях; память O(1) (in-place, кроме рекурсии в heapify).
Пример вывода:
Исходный массив: 12 11 13 5 6 7
Отсортированный массив: 5 6 7 11 12 13
## 8. Последовательный (линейный) поиск
Объяснение: простой перебор элементов слева направо, сравнение с искомым; возвращает индекс при первом совпадении.
Big O: O(n) время, O(1) память.
Пример вывода:
Исходный массив: [3, 5, 2, 7, 9, 1, 4]
Элемент 7 найден на позиции (0-based): 3
## 9. Бинарный (двоичный) поиск
Объяснение: поддерживаем границы left/right, вычисляем mid и сравниваем; с каждым шагом уменьшаем область поиска вдвое. Требуется отсортированный массив.
Big O: O(log n) время, O(1) память.
Пример вывода:
Исходный отсортированный массив: 1 3 5 7 9 11 13 15
Элемент 7 найден на позиции (0-based): 3
## 10. Интерполяционный поиск 
Объяснение: предсказываем позицию искомого на основе линейной интерполяции между значениями концов участка; затем сужаем область аналогично бинарному поиску, но точка сравнения адаптивна. Работает лучше при равномерно распределённых данных.
Big O: O(log log n) при равномерном распределении; O(n) в худшем. Память: рекурсивная глубина (в рекурсивной реализации).
Пример вывода:
Исходный массив: [10, 20, 30, 40, 50, 60, 70, 80]
Элемент 50 найден на позиции (0-based): 4
## 11. Поиск по Фибоначчи
Объяснение: используется последовательность Фибоначчи для выбора индексных шагов; похож на бинарный поиск, но деления основаны на числах Фибоначчи.
Big O: O(log n) время, O(1) память.
Пример вывода:
Исходный массив: [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
Элемент 85 найден на позиции (0-based): 8
